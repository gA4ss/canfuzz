# 介绍
建立TCP链接，此模块可以建立服务器也可以建立客户端，两端可以通讯。做一些模块仿真业务的扩展功能做支撑，也可以根据协议自己编写通讯实现复杂功能。

# 初始化参数

|名称|类型|默认值|描述|
|---|----|-----|---|
|"mode"|字符串|取值从 *["server", "client"]*，默认*server*|是服务器还是客户端。|
|"port"|整型|*19780*|链接或者监听的端口。|
|"address"|字符串|*127.0.0.1*|远程或者本地监听地址。|

# 动作参数

|名称|类型|默认值|描述|
|---|----|-----|---|
|"action"|字符串|取值从 *["read", "write"]* ，默认为 *"read"*|对数据流进行读写操作。|
||||*"read"*，从网络中读取CAN数据并传输回到管道中。|
||||*"write"*，将从管道中读取的CAN数据写入到网络中。|


# 命令

|名称|参数|回调函数|描述|
|---|----|-------|----|
|"write"|<数据帧字符串>|`dev_write`|直接发送CAN数据帧, 类似如下字符串形式: 304:8:07df300101000000。|

# `hw_TCP2CAN`类
此类是子模块的主要实现类。子模块按照配置来启动是作为服务器还是客户端。并且将# `CustomTCPClient`类或者`CustomTCPServer`类的实例都保存在`_server`变量中，并且反向设置了，以上两个类的类变量`selfx`为子模块类的对象。这样在两个功能类的内部就可以调用`selfx`变量来访问子模块类的一些功能函数了。

* `do_init`       初始化做一些参数填充后调用`do_start`函数。
* `do_start`      启动子模块类。启动服务器或者启动客户端。
* `do_stop`       关闭服务器或者关闭客户端。
* `get_status`    获取当前收发数据包的数量与链接状态，填充`CmdResult`结构返回。
* `dev_write`     发送can数据的封装函数。命令`write`的具体实现。

# `CustomTCPClient`类
客户端类，在创建时会启动`self._thread = threading.Thread(target=self.handle)`一个线程。zai`handle`里。会不断执行一个循环来接收服务器的数据。这个循环分为两个阶段，第一个阶段是请求服务器来接收数据包，第二个阶段是发送数据包。两个阶段交替执行。首先请求服务器，如果服务器存在数据流则接收接收完毕等待事件同步，同步完成后发送数据到服务器。交替循环。接收阶段的数据会存到`CANList_in`变量，发送的数据会从`CANList_out`发送。

类变量`selfx`保存了`hw_TCP2CAN`类的对象用于子模块类沟通。

此类提供了三个对外功能函数：

* `write_can`   向服务器发送can数据。
* `read_can`    接收来自服务器的can数据。
* `close`       关闭链接。

## 链接服务器协议

1. 发送`'c\x01\x00\x00'`给服务器。
2. 接收服务器的4个字节回应包：前两个字节是：`'c\x02'`，用来表明是服务器的回应，后面两个字节是实际数据的包个数，一个包16个字节。也就是说如果接收到4这个包数据，那么随后便有$16 \times 4$字节的数据需要接收。
3. 每个包头三个字节都为`'ct\x03'`，随后是4个字节的canid，1个字节的数据长度，8个字节的数据。

### 链接包

|协议头|包个数|
|-----|-----|
|`'c\x02'`|2个字节|

### 数据包

|包头|*canid*|长度|数据|
|---|--------|---|---|
|`'ct\x03'`|4个字节|1个字节|8个字节|

## 发送服务器协议

1. 在发送给服务器数据包之前，有个协议包的确定。总共4个字节，头两个是协议头，后两个字节是数据包个数。
2. 每个包的头两个字节是`'ct\x05'`后面是CAN数据，4个字节的canid，1个字节的长度，8个字节的数据。

### 链接包

|协议头|包个数|
|-----|-----|
|`'c\x04'`|2个字节|

### 数据包

|包头|*canid*|长度|数据|
|---|--------|---|---|
|`'ct\x05'`|4个字节|1个字节|8个字节|

*这里CAN包数据如果字段没有占用满，则使用0补齐。*

```python
# 16字节，CAN包数据如果字段没有占用满，则使用0补齐
send_msg += b'ct\x05' + (b'\x00' * (4 - len(can_msg.frame_raw_id))) + can_msg.frame_raw_id + can_msg.frame_raw_length + can_msg.frame_raw_data + (b'\x00' * (8 - can_msg.frame_length))
```

# `CustomTCPServer`类
此类继承自`socketserver.ThreadingTCPServer`，提供了`write_can`与`read_can`和`close`三个对外函数，主要在`ThreadedTCPRequestHandler`类中维护数据包的队列以及服务器本身的状态。具体请求实现在`ThreadedTCPRequestHandler`类中。

类变量`selfx`保存了`hw_TCP2CAN`类对象的指针，方便与`hw_TCP2CAN`类进行沟通。

# `ThreadedTCPRequestHandler`类
此类是服务器实现请求处理的主要类继承自`socketserver.BaseRequestHandler`，此类的类变量`server`保存了`CustomTCPServer`类的对象实例。实现与服务器类本身的沟通。

此类主要是实现了重载函数`handle`，在此函数中不停的接收客户端来的请求，并判断请求是要获取数据包，还是发送来数据包。
```python
# 判断第一个字节是否是'c'
if data[0:1] == b'c':
  if data[1] == 1:
    # 发送给客户端数据
  elif data[1] == 4:
    # 接收来自客户端的数据
```
发送给客户端的数据来自`self.server.CANList_out`，接收客户端发来的数据来自`self.server.CANList_in`。具体协议可以参考`CustomTCPClient`类中的说明。
